# importar los basicos
from e4lib.e4c.basics import e4c_context
# importar las estructuras
from e4lib.e4c.struct import e4c_struct
# importar los tipos
from e4lib.e4c.types import e4c_type_size
# importar regex
import re
# parseador de e4c
class e4c_parser:
    # inicializador
    def __init__(self):
        pass
    # para inicializar un contexto con mas o menos ya una stdlib
    @staticmethod
    def init_stdlib() -> e4c_context:
        # contexto
        context = e4c_context()
        # añadir tipos
        context.types["char"] = e4c_type_size.IntUint8
        # tipo de algo
        context.types["short"] = e4c_type_size.IntUint16
        # tipo de int
        context.types["int"] = e4c_type_size.IntUint32
        # tipo de long
        context.types["long"] = e4c_type_size.IntUint64
        # retornar
        return context
    # para resolver una expresion
    @staticmethod
    def solve_expretion(context:e4c_context, exp:str):
        pattern = r"(\w+)\.(\w+)"

        match = re.search(pattern, exp)
        if match:
            struct_name, field = match.groups()
            return e4c_struct.get_struct_field(context, struct_name, field, "a")
        elif exp in context.variables:
            # el tamaño
            size = context.variables[exp].value
            # get byte
            directive = "gub "
            # si es 4
            if size == 4:
                # get long
                directive = "gul "
            return ";; e4c: save vars\npush ds ;; e4c: save ds\npush off ;; e4c: save offset\n;; e4c: get variable\nivar " + exp + ",0 ;; e4c: variable\nalign 0 ;; e4c: offset 0\n" + directive + "a ;; e4c: get variable value\npop off ;; e4c: load off\npop ds ;; e4c: load ds\n\n"
        else:
            return ""

    # para parsear
    @staticmethod
    def parse_code(code: str):
        context = e4c_parser.init_stdlib()
        code_result = ""
        # conteo de tabs
        count_of_tabs = 0
        # parsear estructuras
        code_result += e4c_parser.parse_struct(context, code)
        # parsear estructuras implementadas
        code_result += e4c_parser.parse_struct_impls(context, code)
        # eliminar definiciones de struct {...};
        code_no_structs = re.sub(r"struct\s+\w+\s*{[^}]*};", "", code, flags=re.S)
        # eliminar instancias de struct Nombre variable;
        code_no_structs = re.sub(r"struct\s+\w+\s+\w+\s*;", "", code_no_structs)
        # separar por ;
        code_lines = e4c_parser.split_semicolon_outside_quotes(code_no_structs)
        # lineas
        for linem in code_lines:
            # la linea
            line_r = linem.strip()
            # el match
            match = re.match(r"void\s+(\w+)\s*\(\)\s*{(.*)", line_r)
            # si matchea
            if match:

                # los nombres
                func_name, body = match.groups()
                # llamar
                code_result += ("\t" * count_of_tabs) + ";; e4c: autogenerated\n"  + ("\t" * count_of_tabs) + "label " + func_name + "\n"
                # el cuerpo es la linea
                line_r = body
                # conteo de tabs
                count_of_tabs += 1
            # si no hay linea
            if not line_r:
                # continuar
                continue
            # si esta vacia
            if line_r.__len__() == 0:
                # continuar
                continue
            # matchear
            match = re.match(r"^(\w+)\.(\w+)\s*=\s*(.+)$", line_r)

            if line_r.endswith("()"):
                # linea
                func = line_r[0:line_r.__len__() - 2].strip()
                # instruccion
                instr = "call "
                # si inicia con eso
                if func.startswith("for "):
                    # loop
                    instr = "loop "
                    # funcion
                    func = func[4:]
                # llamar
                code_result += ("\t" * count_of_tabs) + instr + func + "\n"
                continue
            # si matchea
            if match:
                # variables
                struct_name, field, value = match.groups()
                # expresion
                expretion = value
                # registro a usar
                use_reg = None
                # si no es un digito
                if not str.isdigit(value):
                    # para guardar
                    code_result += ("\t" * count_of_tabs) + "push a ;; e4c: saving register a\n"
                    # resolver expresion
                    code_result += e4c_parser.solve_expretion(context, expretion)
                    # registro a
                    use_reg = "a"
                # añadir el seteo
                code_result += e4c_struct.set_struct_field(context, struct_name, field, value, use_reg)
                # si no es un digito recuperar
                if not str.isdigit(value):
                    # recuperacion
                    code_result += ("\t" * count_of_tabs) + "pop a ;; e4c: loading register a\n"
            else:
                # arrays
                match = re.match(r"^(\w+)\s+(\w+)\s*\[(\d+)\]$",line_r)
                # si coincide
                if match:
                    # variables
                    type_name, var_name, size = match.groups()
                    # tamaño
                    size = context.types[type_name].value * int(size)
                    # resultado
                    code_result += ("\t" * count_of_tabs) + "db " + var_name + "," + str(size) + " ;; e4c: create variable\n"
                    # añadir
                    context.arrays[var_name] = context.types[type_name]
                else:
                    # variables
                    match = re.match(r"^(\w+)\s+(\w+)",line_r)
                    # si coincide
                    if match:
                        # variables
                        type_name, var_name = match.groups()
                        # añadir
                        context.variables[var_name] = context.types[type_name]
                        # resultado
                        code_result += ("\t" * count_of_tabs) + "db " + var_name + "," + str(context.types[type_name].value) + " ;; e4c: create variable\n"
                    else:
                        # variables asignadas
                        match = re.match(r"^(\w+)\s+=\s+(\w+)", line_r)
                        # si coincide
                        if match:
                            # variables
                            var_name, asignation = match.groups()
                            # si no es un digito
                            if not str.isdigit(asignation):
                                # si no lo es resolverlo
                                code_result += e4c_parser.solve_expretion(context, asignation)
                                # directiva
                                directive = "mov [byte]"
                                # si es 4
                                if context.variables[var_name].value == 4:
                                    # mover 4 bytes
                                    directive = "mov "
                                # añadir la asignacion
                                code_result += ("\t" * count_of_tabs) +";; e4c: set variable\nivar " + var_name + ",0 ;; e4c: select variable\nalign 0 ;; e4c: offset 0\n" + directive + "a\n\n"
                            else:
                                # directiva
                                directive = "pub "
                                # si es 4
                                if context.variables[var_name].value == 4:
                                    # mover 4 bytes
                                    directive = "pul "
                                # añadir la asignacion
                                code_result += ("\t" * count_of_tabs) + "ivar " + var_name + ",0 ;; e4c: select variable\n" + ("\t" * count_of_tabs) +"align 0 ;; e4c: offset 0\n" + ("\t" * count_of_tabs) + directive + asignation + "\n"
                        else:
                            # cerrar
                            if line_r == "}":
                                # retorno
                                code_result += ("\t" * count_of_tabs) + "ret\n"
                                # bajar
                                count_of_tabs -= 1
                            elif line_r.startswith("@"):
                                # instr
                                instr = line_r[1:]
                                # ponerlo
                                # llamar
                                code_result += ("\t" * count_of_tabs) + instr + "\n"

        return code_result
    # para separar el codigo
    @staticmethod
    def split_semicolon_outside_quotes(code: str):
        # Busca ; que no estén dentro de comillas
        parts = re.split(r';(?=(?:[^"]*"[^"]*")*[^"]*$)', code)
        return [p.strip() for p in parts if p.strip()]
    # para parsear estructuras
    @staticmethod
    def parse_struct_impls(context: e4c_context, code: str):
        # buscar todas las estructuras
        matches = re.finditer(r"struct\s+(\w+)\s+(\w+);", code, re.S)
        # codigo
        code_result = ";; e4c: structs impl autogenerated\nlabel e4c.impl_structs\n"
        # matches
        for match in matches:
            # cuerpo
            struct, name = match.groups()
            # estructuras
            context.struct_vars[name] = struct
            # appendear codigo
            code_result += "\tdb " + name + "," + str(context.structures.get(struct).total_size) + " ;; e4c: autogenerated\n"
        # resultado
        return code_result
    # para parsear estructuras
    @staticmethod
    def parse_struct(context: e4c_context, code: str):
        # buscar todas las estructuras
        matches = re.finditer(r"struct\s+(\w+)\s*({[^}]*});", code, re.S)
        # codigo
        code_result = ";; e4c: structs autogenerated\nlabel e4c.structs\n"
        # matches
        for match in matches:
            # cuerpo
            name, body = match.groups()
            # estructura
            struct = e4c_struct(body, context.types)
            # contexto
            context.structures[name] = struct
            # appendear codigo
            code_result += "    ;; e4c: struct created " + name + " with size " + str(struct.total_size) + "\n"
        # resultado
        return code_result